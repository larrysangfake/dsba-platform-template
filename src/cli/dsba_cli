#!python3
# This first line with #! ("shebang") tells the system that this is a script
# Note that this file has been marked as "executable" for the OS using the command "chmod +x"
import argparse
from html import parser
import logging
import os
import sys
from typing import Any
from pathlib import Path

from dsba.data_ingestion import load_csv_from_path, write_csv_to_path
from dsba.model_registry import list_models_ids, load_model, load_model_metadata
from dsba.model_prediction import predict_five_day_average #New function for prediction

#import yfiance
import yfinance as yf

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%H:%M:%S,",
)


def create_parser():
    """
    We use the library argparse to define the functionalities of our CLI,
    it will also do the magic to turn the command line typed by the user into an easy to use python object.

    We want to define a commend line that does
    dsba_cli [command] [options]
    """
    parser = argparse.ArgumentParser(description="DSBA Plaftorm CLI Tool")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # List models command (it has no additional parameters)
    subparsers.add_parser("list", help="List available models")

    # Predict command (it requires a model name, an input file and an output file)
    predict_parser = subparsers.add_parser("predict", help="Make predictions")
    predict_parser.add_argument("--model", help="Model name to use", required=True)
    predict_parser.add_argument("--input", help="Input file path", required=True)
    predict_parser.add_argument("--output", help="Output file path", required=True)

    # Analyze command (new)
    analyze_parser = subparsers.add_parser("analyze", help="Analyze stock performance")
    analyze_parser.add_argument("--company", help="Company name or stock code", required=True)
    analyze_parser.add_argument("--shares", help="Number of shares owned", type=int, required=True)
    analyze_parser.add_argument("--price", help="Acquisition price per share", type=float, required=True)
    analyze_parser.add_argument("--min_gain", help="Minimum acceptable gain", type=float, required=True)
    analyze_parser.add_argument("--expected_gain", help="Expected average gain", type=float, required=True)

    return parser


def get_script_args():
    parser = create_parser()
    return parser.parse_args()


def main():
    args = get_script_args()
    if args.command == "list":
        list_models()
    elif args.command == "predict":
        predict(args.model, args.input, args.output)
    elif args.command == "analyze":
        analyze(args.company, args.shares, args.price, args.min_gain, args.expected_gain)




# We create a few light wrappers around our platform functionalities, just collect inputs and print the results.


def list_models() -> None:
    models = list_models_ids()
    print("Available models:")
    for model in models:
        print(f"- {model}")


def predict(model_id: str, input_file: str, output_file: str) -> None:
    """
    Make predictions using a specified model."
    """
    try:
        model = load_model(model_id)
        metadata = load_model_metadata(model_id)
        df = load_csv_from_path(input_file)
        predictions = predict_five_day_average(model, df, metadata.target_column)
        write_csv_to_path(predictions, output_file)
        print(f"Predicted prices saved to {output_file}")
    except Exception as e:
        logging.error(f"Failed to make predictions: {e}")

# New function for analyzing stock performance
def analyze(company_code: str, num_shares: int, acquisition_price: float, min_gain: float, expected_gain: float) -> None:
    """
    Analyze stock performance and calculate potential gain.
    """
    try:
        # Fetch historical stock data
        stock_data = yf.download(company_code, period="1mo")  # Last month's data
        historical_prices = stock_data["Close"].tolist()

        # Load the model and metadata
        model = load_model("arima_model")  # Example model ID
        metadata = load_model_metadata("arima_model")

        # Predict the next five working days' average price
        predicted_avg_price = predict_five_day_average(model, historical_prices, metadata.target_column)

        # Calculate potential gain
        acquisition_cost = num_shares * acquisition_price
        predicted_value = num_shares * predicted_avg_price
        potential_gain = predicted_value - acquisition_cost

        # Compare gain to user expectations
        if potential_gain >= expected_gain:
            recommendation = "Sell now"
        elif potential_gain >= min_gain:
            recommendation = "Consider selling"
        else:
            recommendation = "Hold"

        # Print the results
        print(f"Predicted average price (next 5 days): {predicted_avg_price:.2f}")
        print(f"Potential gain: {potential_gain:.2f}")
        print(f"Recommendation: {recommendation}")
    except Exception as e:
        logging.error(f"Error analyzing stock: {e}")



if __name__ == "__main__":
    main()
